---
title: "Cluster Analysis"
output: html_document
params:
  k: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
if(!require(pacman)){
  install.packages("pacman")
}
pacman::p_load(tidyverse, data.table, heatmap3, randomForest)
source('~/MasterProjects/timeseries_analysis/data.R')
k = as.integer(params$k)
filename.features = "features_20190311_systIII_siPOOLs_plate1and2_singlePulses_rec_filtered.csv"
filename.tdata = "tdata_20190311_systIII_siPOOLs_plate1and2_singlePulses.csv"
nuc.erk = "objNuc_Intensity_MeanIntensity_imErk"
cyto.erk = "objCyto_ring_Intensity_MeanIntensity_imErk"
#cyto.erk = "objCyto_Intensity_MeanIntensity_imErk" # alterntive in older Experiments
time.var = "Image_Metadata_T"
stim.var = "Stimulation_treatment"
stim.time.var = "Stimulation_time"
group.var = c("Image_Metadata_Site", "track_id")
track.var = "track_id"
erk.ratio.var = "erk.ratio"
meta.grouping = "Grouping"
site.var = "Image_Metadata_Site"
filename.tdata.mp = ""
```


```{r check_feature_outlier_detection}


# features.clean
# features.outliers
# all.ex.pos.features.clean
# all.ex.pos.features
# 
# 
# dt.data.w.features_class = all.ex.pos.features
# dt.data.w.features_class[is.na(dt.data.w.features_class)] = 1000
# prediction = predict(classifier, dt.data.w.features_class)
# length(prediction[which(prediction == 1)])/length(prediction)

## check what stim_treatments get discarded!
outliers = which(prediction == 1)
a = table(dt.data.w.features_class[outliers,]$Stimulation_treatment)
b = table(dt.data.w.features_class[-outliers,]$Stimulation_treatment) # remove lots of plus control which is expected!


pos.ctrl.features_class = pos.ctrl.features
pos.ctrl.features_class[is.na(pos.ctrl.features_class)] = 1000
prediction = predict(classifier, pos.ctrl.features_class)
outliers_pos = which(prediction == 1)
c = table(pos.ctrl.features_class[outliers_pos,]$Stimulation_treatment)
d = table(pos.ctrl.features_class[-outliers_pos,]$Stimulation_treatment)
sum(table(pos.ctrl.features_class[outliers_pos,]$Stimulation_treatment))/length(pos.ctrl.features_class$Stimulation_treatment)

at = data.frame(a) %>% rename("Freq1" = Freq)
bt = data.frame(b) %>% rename("Freq2" = Freq)
outtable = dplyr::full_join(at, bt) %>% mutate(perc_outlier = Freq1/(Freq2+Freq1)) %>% mutate(perc_outlier = round(perc_outlier, digits = 3))
outtable = `colnames<-`(outtable, c("Treatment", "oultier", "not outlier", "precentage of outliers"))
knitr::kable(t(outtable))
```

```{r theme_function, echo = FALSE, include = FALSE}
#stolen from dmattek tca-package
ggplotTheme = function(in.font.base = 12,
                       in.font.axis.text = 12,
                       in.font.axis.title = 12,
                       in.font.strip = 14,
                       in.font.legend = 12) {
  loc.theme =
    theme_bw(base_size = in.font.base, base_family = "Helvetica") +
    theme(
      panel.spacing = unit(1, "lines"),
      panel.grid.minor = element_blank(),
      panel.grid.major = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(color = "black", size = 0.25),
      axis.text = element_text(size = in.font.axis.text),
      axis.title = element_text(size = in.font.axis.title),
      strip.text = element_text(size = in.font.strip, face = "bold"),
      strip.background = element_blank(),
      legend.key = element_blank(),
      legend.text = element_text(size = in.font.legend),
      legend.key.height = unit(1, "lines"),
      legend.key.width = unit(2, "lines"))
  
  return(loc.theme)
}
```

## `r filename.features`

Loading of the necessary Data and transfering
```{r dataloading}
data.clean = data.table::fread(filename.features)
dt.data = fread(filename.tdata)
```
Pool all the WT and negative as well as posive CTRL together

```{r pooling wt and ctrl}
features.clean.pooled = data.clean %>% mutate(Stimulation_treatment = case_when(
  Stimulation_treatment %like% "\\+CTRL" ~ "+CTRL",
  Stimulation_treatment %like% "\\-CTRL" ~ "-CTRL",
  Stimulation_treatment %like% "WT" ~ "WT",
  TRUE ~ as.character(Stimulation_treatment)
) ) 
```

Normalisation of the data
```{r normalize}
source("normalize_data_frame.R")
data.pooled.n = normalize_frame(features.clean.pooled, -site.var, -track.var)
```

Create named matrix of the normalized features

```{r named_matrix}
names = data.pooled.n %>% pull(var = stim.var)
cluster.data.n = data.pooled.n %>% ungroup()  %>% 
  select(-site.var, -track.var) %>% #, -dip.time.min, -mean, -sd, -FMWH.left, -FMWH.right, -noise) %>% 
  select_if(is.numeric) 
m = as.matrix(cluster.data.n)
rownames(m) = names
```

Create distance matrx and cluster with hc clust

```{r distm}
distance_m = dist(m, method = "euclidean")
hr <- hclust(distance_m, method = "ward.D2")
```

Clustered Heatmap of features with `r k` Clusters

```{r heat1}
mycl <- cutree(hr, k = k)
cl = as.factor(mycl)
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
mycolhc <- gg_color_hue(k)
mycolhc_c <- mycolhc[as.integer(as.vector(cl))] 
m_clipped = m # hard clipping, ouliers disturbe colors
m_clipped[m_clipped > 3 ] = 3
m_clipped[m_clipped < -3] = -3
heatmap3(m_clipped, Rowv =as.dendrogram(hr), Colv = NA, scale = "none", RowSideColors = mycolhc_c)
```

Heat map but with Columns clustered aswell
```{r}
distance_m_c = dist(t(m), method = "euclidean")
hc <- hclust(distance_m_c, method = "ward.D")
heatmap3(m_clipped, Rowv =as.dendrogram(hr), Colv = as.dendrogram(hc), RowSideColors = mycolhc_c) 
```

From dendrogram, get cluster information and create cluster distance plot.

```{r}
cluster.freq = data.frame(cl = as.vector(mycl), type = names(mycl))
summ = cluster.freq %>% group_by(cl, type) %>% summarise(count = n())  %>% ungroup() %>% mutate(cl = as.factor(cl))

ggplot(summ,aes(x = type, y = count, fill = cl)) + 
    geom_bar(position = position_fill(reverse = TRUE),stat = "identity") +
    scale_y_continuous(labels = scales::percent_format()) +
    ggplotTheme() + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
    labs(y = "precentage of trajectories", fill = "Cluster no.", x = "siRNA treatment")
```


File containing for the Features and therefore for the unique label in which clusters it belongs. Merge with time series data to plot cluster averages

Analyse clusters averages
```{r}
# should still have same ordering as features table
cluster.freq = mutate(cluster.freq,Image_Metadata_Site = data.clean %>% pull(site.var))
cluster.freq = mutate(cluster.freq,track_id = data.clean %>% pull(track.var))
# cluster.freq$Image_Metadata_Site = data.clean$Image_Metadata_Site
# cluster.freq$objNuc_TrackObjects_Label = data.clean$objNuc_TrackObjects_Label

timeseries.clustered = left_join(cluster.freq, dt.data)

summarised_clusters = timeseries.clustered %>%
  mutate(cl = as.factor(cl)) %>%
  group_by_("cl", time.var) %>% summarise(mean_cl_at_t = mean(erk.ratio)) 

ggplot(summarised_clusters, aes(y = mean_cl_at_t, x = get(time.var), color =  cl, group = cl)) +
  geom_line() +
  labs(x = "Real Time (min)" , y = "Cytoplasmic to Nuclear intensity ratio ERK", color = "Cluster") +
  ggplotTheme()

```


<!-- Clusters as exported from shiny app -->
<!-- ```{r, message=FALSE} -->
<!-- cluster.to.unique = fread("clusternalysisdata/tabClHier-downCellCl") -->
<!-- cluster.to.unique <- cluster.to.unique %>% separate(id, c('Image_Metadata_Site', 'objNuc_TrackObjects_Label')) %>% mutate_all(as.numeric) -->
<!-- timeseries.clustered = left_join(cluster.to.unique, dt.data) -->

<!-- summarised_clusters = timeseries.clustered %>% -->
<!--   mutate(cl = as.factor(cl)) %>% -->
<!--   group_by(cl, RealTime) %>% summarise(mean_cl_at_t = mean(erk.ratio))  -->

<!-- ggplot(summarised_clusters, aes(y = mean_cl_at_t, x = RealTime, color =  cl, group = cl)) + -->
<!--   geom_line() + -->
<!--   labs(x = "Real Time (min)" , y = "Cytoplasmic to Nuclear intensity ratio ERK", color = "Cluster") + -->
<!--   ggplotTheme() -->

<!-- ``` -->

## train a randomForest classifier on the features. Create a model that predicts Stimulation_Treatment and look at feature importance.
```{r named}


#rnd.features = data.clean
rnd.features = features.clean.pooled
rnd.features[is.na(rnd.features)] = 1000
rnd.features = select(rnd.features, -site.var)
rnd.features = select(rnd.features, -track.var)
rnd.features = mutate(rnd.features,Stimulation_treatment = as.factor(get(stim.var)))
forest_class = randomForest(Stimulation_treatment~.,rnd.features)
coeff = as.data.table(importance(forest_class))
coeff$coeff = rownames(importance(forest_class))


ggplot(coeff, aes(y = MeanDecreaseGini, x = coeff, fill = MeanDecreaseGini)) + 
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## Repetition of clustering Analysis with only important features according to random Forest
```{r}
arrange(coeff, MeanDecreaseGini)[-(1:5),]$coeff

names = data.pooled.n %>% pull(stim.var)
cluster.data.n = data.pooled.n %>% ungroup()  %>% 
  select(-site.var, -track.var) %>% select(-c(arrange(coeff, MeanDecreaseGini)[1:5,]$coeff)) %>%#, -dip.time.min, -mean, -sd, -FMWH.left, -FMWH.right, -noise) %>% 
  select_if(is.numeric) 
m = as.matrix(cluster.data.n)
rownames(m) = names
distance_m = dist(m, method = "euclidean")
hr <- hclust(distance_m, method = "ward.D2")
mycl <- cutree(hr, k = k)
cl = as.factor(mycl)
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
mycolhc <- gg_color_hue(k)
mycolhc_c <- mycolhc[as.integer(as.vector(cl))] 
m_clipped = m # hard clipping, ouliers disturbe colors
m_clipped[m_clipped > 3 ] = 3
m_clipped[m_clipped < -3] = -3
heatmap3(m_clipped, Rowv =as.dendrogram(hr), Colv = NA, scale = "none", RowSideColors = mycolhc_c)
```
Heat map but with Columns clustered aswell
```{r}
distance_m_c = dist(t(m), method = "euclidean")
hc <- hclust(distance_m_c, method = "ward.D")
#pdf("heatmap")
heatmap3(m_clipped, Rowv =as.dendrogram(hr), Colv = as.dendrogram(hc), RowSideColors = mycolhc_c) 
#dev.off()
```

From dendrogram, get cluster information and create cluster distance plot.

```{r}
cluster.freq = data.frame(cl = as.vector(mycl), type = names(mycl))
summ = cluster.freq %>% group_by(cl, type) %>% summarise(count = n())  %>% ungroup() %>% mutate(cl = as.factor(cl))

gga = ggplot(summ,aes(x = type, y = count, fill = cl)) + 
    geom_bar(position = position_fill(reverse = TRUE),stat = "identity") +
    scale_y_continuous(labels = scales::percent_format()) +
    ggplotTheme() + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
    labs(y = "precentage of trajectories", fill = "Cluster no.", x = "siRNA Treatment")
plot(gga)
ggsave(filename = "clusterdist_ggplot", plot = gga, device = "svg")

```


File containing for the Features and therefore for the unique label in which clusters it belongs. Merge with time series data to plot cluster averages

Analyse clusters averages
```{r}
# should still have same ordering as features table
cluster.freq = mutate(cluster.freq,Image_Metadata_Site = data.clean %>% pull(site.var))
cluster.freq = mutate(cluster.freq,track_id = data.clean %>% pull(track.var))
# cluster.freq$Image_Metadata_Site = data.clean$Image_Metadata_Site
# cluster.freq$objNuc_TrackObjects_Label = data.clean$objNuc_TrackObjects_Label

timeseries.clustered = left_join(cluster.freq, dt.data)

summarised_clusters = timeseries.clustered %>%
  mutate(cl = as.factor(cl)) %>%
  group_by_("cl", time.var) %>% summarise(mean_cl_at_t = mean(erk.ratio)) 

gg = ggplot(summarised_clusters, aes(y = mean_cl_at_t, x = get(time.var), color =  cl, group = cl)) +
  geom_line() +
  labs(x = "Real Time (min)" , y = "Cytoplasmic to Nuclear intensity ratio ERK", color = "Cluster") +
  ggplotTheme()
plot(gg)
ggsave(filename = "clusteraverages_ggplot", plot = gg, device = "svg")
```

##Remove positive CTRL from clustering
This is sensable because +CTRL uses almost two hole clusters for itself. But we can use one sluter more.

```{r clusterexposctrl}
k = 8 # without +CTRL is ok
arrange(coeff, MeanDecreaseGini)[-(1:5),]$coeff

data.pooled = data.clean %>% 
  filter(!get(stim.var) %like% "\\+CTRL") %>% 
  mutate(Stimulation_treatment = case_when(stim.var %like% "WT" ~ "WT",
                                           stim.var %like% "CTRL" ~ "-CTRL",
                                           TRUE ~ as.character(get(stim.var))))
data.pooled.n = normalize_frame(data.pooled, -site.var, -track.var)


names = data.pooled.n %>% pull(stim.var)
cluster.data.n = data.pooled.n %>% ungroup()  %>% 
  select(-site.var, -track.var) %>% select(-c(arrange(coeff, MeanDecreaseGini)[1:5,]$coeff)) %>%#, -dip.time.min, -mean, -sd, -FMWH.left, -FMWH.right, -noise) %>% 
  select_if(is.numeric) 
m = as.matrix(cluster.data.n)
rownames(m) = names
distance_m = dist(m, method = "euclidean")
hr <- hclust(distance_m, method = "ward.D2")
mycl <- cutree(hr, k = k)
cl = as.factor(mycl)
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
mycolhc <- gg_color_hue(k)
mycolhc_c <- mycolhc[as.integer(as.vector(cl))] 
m_clipped = m # hard clipping, ouliers disturbe colors
m_clipped[m_clipped > 3 ] = 3
m_clipped[m_clipped < -3] = -3
heatmap3(m_clipped, Rowv =as.dendrogram(hr), Colv = NA, scale = "none", RowSideColors = mycolhc_c)
```
Heat map but with Columns clustered aswell
```{r}
distance_m_c = dist(t(m), method = "euclidean")
hc <- hclust(distance_m_c, method = "ward.D")
heatmap3(m_clipped, Rowv =as.dendrogram(hr), Colv = as.dendrogram(hc), RowSideColors = mycolhc_c) 
```

From dendrogram, get cluster information and create cluster distance plot.

```{r}
cluster.freq = data.frame(cl = as.vector(mycl), type = names(mycl))
summ = cluster.freq %>% group_by(cl, type) %>% summarise(count = n())  %>% ungroup() %>% mutate(cl = as.factor(cl))

ggplot(summ,aes(x = type, y = count, fill = cl)) + 
    geom_bar(position = position_fill(reverse = TRUE),stat = "identity") +
    scale_y_continuous(labels = scales::percent_format()) +
    ggplotTheme() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    labs(y = "precentage of trajectories", fill = "Cluster no.", x = "siRNA treatment")
```


File containing for the Features and therefore for the unique label in which clusters it belongs. Merge with time series data to plot cluster averages

Analyse clusters averages
```{r}
# should still have same ordering as features table
cluster.freq = mutate(cluster.freq,Image_Metadata_Site = data.pooled.n %>% pull(site.var))
cluster.freq = mutate(cluster.freq,track_id = data.pooled.n %>% pull(track.var))
# cluster.freq$Image_Metadata_Site = data.pooled.n$Image_Metadata_Site
# cluster.freq$objNuc_TrackObjects_Label = data.pooled.n$objNuc_TrackObjects_Label

timeseries.clustered = left_join(cluster.freq, dt.data)

summarised_clusters = timeseries.clustered %>%
  mutate(cl = as.factor(cl)) %>%
  group_by_("cl", time.var) %>% summarise(mean_cl_at_t = mean(erk.ratio)) 

ggplot(summarised_clusters, aes(y = mean_cl_at_t, x = get(time.var), color =  cl, group = cl)) +
  geom_line() +
  labs(x = "Real Time (min)" , y = "Cytoplasmic to Nuclear intensity ratio ERK", color = "Cluster") +
  ggplotTheme()


```


```{r featurecorreleation}
names = data.pooled.n$Stimulation_treatment
cluster.data.n = data.pooled.n %>% ungroup()  %>% 
  select(-site.var, -track.var) %>% #, -dip.time.min, -mean, -sd, -FMWH.left, -FMWH.right, -noise) %>% 
  select_if(is.numeric) 
m = as.matrix(cluster.data.n)
fcorr = cor(na.omit(m))
fcorr.df = data.frame(fcorr)
fcorr.df$type = rownames(fcorr.df)
cor.long = gather(fcorr.df, "type1","Correlation",-type)
ggplot(cor.long, aes(y = reorder(type, Correlation), x = reorder(type1, Correlation), fill = Correlation)) + 
  geom_tile() + scale_fill_gradient2(low = "blue", high= "red", mid = "white") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = "Correlation of Features" , x = "" , y = "")

```

Correlation after removing Features accoring to importance created by random Forest.
```{r}
names = data.pooled.n %>% pull(site.var)
cluster.data.n = data.pooled.n %>% ungroup()  %>% 
  select(-site.var, -track.var) %>% 
  select(-c(arrange(coeff, MeanDecreaseGini)[1:5,]$coeff)) %>% #, -dip.time.min, -mean, -sd, -FMWH.left, -FMWH.right, -noise) %>% 
  select_if(is.numeric) 
m = as.matrix(cluster.data.n)
fcorr = cor(na.omit(m))
fcorr.df = data.frame(fcorr)
fcorr.df$type = rownames(fcorr.df)
cor.long = gather(fcorr.df, "type1","Correlation",-type)
ggplot(cor.long, aes(y = reorder(type, Correlation), x = reorder(type1, Correlation), fill = Correlation)) + 
  geom_tile() + scale_fill_gradient2(low = "blue", high= "red", mid = "white") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = "Correlation of Features" , x = "" , y = "")

```


```{r}
require(Rtsne)

# # try tsne stuff
# labels = na.omit(data.pooled.n) %>% pull(stim.var)
# train<- data.pooled.n %>% select(-site.var, -track.var, -stim.var)## Choose the train.csv file downloaded from the link above  
# ## Curating the database for analysis with both t-SNE and PCA
# 
# labels<-as.factor(labels)
# ## for plotting
# colors = rainbow(length(unique(labels)))
# names(colors) = unique(labels)
# 
# ## Executing the algorithm on curated data
# tsne <- Rtsne(na.omit(train), dims = 2, perplexity=50, verbose=TRUE, max_iter = 1800, eta = 300)
# 
# ## Plotting
# x = data.frame(tsne$Y)
# x$type = labels
# ggplot(x, aes(x = X1, y = X2, color = type)) + 
#   geom_point() + theme_classic()

```


